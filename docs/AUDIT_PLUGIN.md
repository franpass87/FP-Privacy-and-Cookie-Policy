# Plugin Audit Report — FP Privacy and Cookie Policy — 2024-05-17

## Summary
- Files scanned: 59/59
- Issues found: 4 (Critical: 0 | High: 3 | Medium: 1 | Low: 0)
- Key risks:
  - Auto-generated policy pages are overwritten on every request, deleting manual edits.
  - Consent submissions fail once cached pages serve an expired REST nonce, blocking cookie collection.
  - WordPress GDPR export/erase tools silently return empty data because requests search by email while the plugin only accepts consent IDs.
  - Consent revision bumps flip the main options record back to autoload=1, inflating every request.
- Recommended priorities: ISSUE-002 → ISSUE-004 → ISSUE-001 → ISSUE-003
- Additional review of the REST exporter and supporting utilities uncovered a DSAR compliance gap; coverage remains 59/59 files.

## Issues
### [High] Policy page auto-refresh overwrites manual content
- ID: ISSUE-001
- File: fp-privacy-cookie-policy/src/Utils/Options.php:704-724
- Snippet:
  ```php
        if ( $post instanceof WP_Post ) {
            $needs_refresh = 'publish' !== $post->post_status || trim( (string) $post->post_content ) !== $content;

            if ( ! $needs_refresh ) {
                continue;
            }

            $result = \wp_update_post(
                array(
                    'ID'           => $post->ID,
                    'post_status'  => 'publish',
                    'post_type'    => 'page',
                    'post_content' => $content,
                ),
                true
            );
  ```

Diagnosis: `ensure_pages_exist()` re-publishes the generated shortcode content whenever the stored page content differs, even if the change was made intentionally by the site owner. Because this runs on plugin boot, any manual edits to the Privacy or Cookie policy pages are silently reverted.

Impact: Functional regression and data loss. Site admins cannot customise legally required policy pages because their changes are undone on the next page load.

Repro steps:
1. Edit the generated Privacy Policy page and add custom text.
2. Load any front-end request (or visit the settings screen).
3. Observe that the page content reverts to the default shortcode output.

Proposed fix (concise):

Only force-refresh when the page is missing/trashed or still contains the original autogenerated marker. Skip `wp_update_post()` if the page is published with non-empty custom content, or store a meta flag when the plugin owns the page and respect it before overwriting.

Side effects / Regression risk: Must ensure first-run provisioning still creates/repairs missing pages while preserving administrator edits.

Est. effort: M

Tags: #ux #data-loss #pages #options

### [High] REST consent endpoint rejects cached visitors after nonce expiry
- ID: ISSUE-002
- File: fp-privacy-cookie-policy/src/REST/Controller.php:138-152
- Snippet:
  ```php
    $nonce = $request->get_header( 'X-WP-Nonce' );
    if ( ! $nonce || ! \wp_verify_nonce( $nonce, 'wp_rest' ) ) {
        return new WP_Error( 'fp_privacy_invalid_nonce', \__( 'Invalid security token.', 'fp-privacy' ), array( 'status' => 403 ) );
    }

    $ip      = isset( $_SERVER['REMOTE_ADDR'] ) ? \sanitize_text_field( \wp_unslash( $_SERVER['REMOTE_ADDR'] ) ) : '';
    $salt    = function_exists( '\fp_privacy_get_ip_salt' ) ? \fp_privacy_get_ip_salt() : 'fp-privacy-cookie-policy-salt';
    $limit   = 'fp_privacy_rate_' . hash( 'sha256', $ip . '|' . $salt );
    $attempt = (int) \get_transient( $limit );
  ```

Diagnosis: Consent submissions require a WordPress REST nonce tied to the rendered page. On anonymous/public pages served from page caches (typical for cookie banners), that nonce expires after 12 hours. Cached HTML keeps the stale nonce, so all later visitors receive 403 responses and cannot record consent until the cache is purged.

Impact: Critical functional failure and regulatory risk—visitors are stuck with an always-visible banner, and their consent state is never stored.

Repro steps:
1. Serve a cached page (e.g. via full-page cache/CDN) for more than 12 hours.
2. Visit the cached page and attempt to accept cookies.
3. The REST request returns 403 “Invalid security token”, leaving the banner open and no consent recorded.

Proposed fix (concise):

Allow a cache-safe token: issue a long-lived consent nonce (e.g. `wp_create_nonce( 'fp_privacy_consent' )` stored alongside the banner cookie or derived from `fp_privacy_get_ip_salt()`), accept it in `post_consent()`, and fall back to the REST nonce for logged-in users. Alternatively, detect nonce failure and provide a lightweight endpoint to mint a fresh token before retrying.

Side effects / Regression risk: Ensure the replacement keeps CSRF protection (tie the custom token to the visitor via salt/IP or a separate cookie) and does not break logged-in flows.

Est. effort: M

Tags: #frontend #rest #cache #csrf #consent

### [Medium] Consent revision bumps re-autoload heavy options row
- ID: ISSUE-003
- File: fp-privacy-cookie-policy/src/Utils/Options.php:641-643
- Snippet:
  ```php
    public function bump_revision() {
        $this->options['consent_revision'] = isset( $this->options['consent_revision'] ) ? (int) $this->options['consent_revision'] + 1 : 1;
        \update_option( self::OPTION_KEY, $this->options );
    }
  ```

Diagnosis: `bump_revision()` writes the full `fp_privacy_options` payload without passing the `$autoload` flag. WordPress therefore switches the row back to `autoload = yes`, defeating the earlier `update_option(..., false)` calls. Given the option stores policy snapshots and banner copy, this can add hundreds of KB to every page load until another save resets it.

Impact: Performance regression (memory & load time) on front-end requests, especially after admins force a consent reset.

Repro steps:
1. Inspect `autoload` flag for `fp_privacy_options` (it is `no` after saving settings).
2. Click “Force new consent (bump revision)” in the admin.
3. Check the option again—`autoload` is now `yes` and remains so.

Proposed fix (concise):

Call `update_option( self::OPTION_KEY, $this->options, false );` so the option stays non-autoloaded when bumping revisions.

Side effects / Regression risk: None expected; behaviour matches other setters.

Est. effort: S

Tags: #performance #options #autoload

### [High] GDPR exporter expects consent IDs, breaking DSAR requests by email
- ID: ISSUE-004
- File: fp-privacy-cookie-policy/src/Consent/ExporterEraser.php:91-175
- Snippet:
  ```php
    public function export_personal_data( $email, $page ) {
        $consent_id = \sanitize_text_field( $email );

        $results = $wpdb->get_results(
            $wpdb->prepare(
                "SELECT * FROM {$this->log_model->get_table()} WHERE consent_id = %s ORDER BY created_at ASC LIMIT %d OFFSET %d",
                $consent_id,
                $per_page,
                $offset
            ),
            ARRAY_A
        );
  ```

Diagnosis: WordPress privacy exports call this callback with the requester’s email address, but the plugin blindly treats that string as a consent identifier. Because consent IDs are random cookie tokens and never match an email, exports (and the paired eraser routine) always return an empty dataset even when consent records exist.

Impact: High regulatory and legal risk—site owners think the DSAR tools exported/erased data, yet every request silently reports “no data,” so they fail to honour GDPR access/erasure requests.

Repro steps:
1. Record a consent (cookie ID stored in the log).
2. In Tools → Export Personal Data, submit the visitor’s email and approve the request.
3. Run the export: the CSV contains no entries because the code queried by email instead of consent ID.

Proposed fix (concise):

Translate the incoming email-based request into consent IDs before querying. For example, store the visitor’s consent ID alongside their user ID/email when known, or add a filter that maps the email to one or more consent IDs and search by those. If no mapping exists, skip registering these GDPR exporters so WordPress doesn’t report a false “success.”

Side effects / Regression risk: Ensure new mappings don’t leak consent tokens and that legacy exports keep working when admins deliberately paste a consent ID.

Est. effort: M

Tags: #compliance #gdpr #exporter #eraser

## Conflicts & Duplicates
- `templates/privacy-policy.php` and `templates/cookie-policy.php` both declare identical helper functions (`fp_privacy_format_service_cookies`, `fp_privacy_get_service_value`). Recommendation: centralise these helpers (e.g. in a shared include) to avoid redeclaration risks and duplicated logic.

## Deprecated & Compatibility
- None observed so far.

## Performance Hotspots
- ISSUE-003: `bump_revision()` re-autoloads a large option record; see fix above.

## i18n & A11y
- No new localisation or accessibility defects identified in this batch.

## Test Coverage
- Only `tests/AutoloaderTest.php` is present; there are no automated tests covering consent REST flows, policy provisioning, or settings handling. Consider adding integration tests for consent submissions and option lifecycle.

## Next Steps (per fase di FIX)
- Ordine consigliato: ISSUE-002, ISSUE-004, ISSUE-001, ISSUE-003
- Safe-fix batch plan:
  - Batch 1: ISSUE-002 (consent REST nonce handling)
  - Batch 2: ISSUE-004 (GDPR exporter identifier mapping)
  - Batch 3: ISSUE-001 (page overwrite guard)
  - Batch 4: ISSUE-003 (autoload flag regression)

